{"ast":null,"code":"var _this = this;\n\nimport { connect, createLocalAudioTrack, createLocalVideoTrack, isSupported, LocalVideoTrack } from 'twilio-video';\nimport CommonService from './common-service';\nlet roomObj;\nlet options = {}; // const subscribed_participants_map: { [userId: string]: RemoteParticipant } = {};\n\nconst mediaErrors = ['NotAllowedError', 'NotFoundError', 'NotReadableError', 'OverconstrainedError', 'TypeError'];\n\nconst toggleAudio = function () {\n  let isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return new Promise(async (resolve, reject) => {\n    if (isOn) {\n      const audioTrack = await createLocalAudio(options.audio).catch(handleMediaError.bind(_this, 'audio'));\n\n      if (audioTrack) {\n        await roomObj.localParticipant.publishTrack(audioTrack);\n        resolve();\n      } else {\n        reject();\n      }\n    } else {\n      turnOffAudio();\n      resolve();\n    }\n  });\n};\n\nconst listOfCameras = () => {\n  return new Promise((resolve, reject) => {\n    const list = [];\n    navigator.mediaDevices.enumerateDevices().then(function (devices) {\n      for (let device of devices) {\n        if (device.kind === 'videoinput') {\n          list.push(device);\n        }\n      }\n\n      resolve(list);\n    }).catch(reject);\n  });\n};\n\nconst toggleVideo = function () {\n  let isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return new Promise(async (resolve, reject) => {\n    if (isOn) {\n      const videoTrack = await createLocalVideo(options.video).catch(handleMediaError.bind(_this, 'video'));\n\n      if (videoTrack) {\n        await roomObj.localParticipant.publishTrack(videoTrack);\n        renderLocalVideo([videoTrack]);\n        resolve(null);\n      } else {\n        reject();\n      }\n    } else {\n      turnOffVideo();\n      resolve(null);\n    }\n  });\n};\n\nconst handleMediaError = (mode, error) => {\n  console.error('Failed to acquire media:', mode, error.name, error.message);\n\n  CommonService._communications.mediaAvailabilitySubject.next({\n    error: error,\n    is_available: false,\n    mode\n  });\n};\n\nconst createLocalTracks = async options => await createLocalTracks(options);\n\nconst createLocalVideo = async options => {\n  return await createLocalVideoTrack(options);\n};\n\nconst createLocalAudio = async options => {\n  return await createLocalAudioTrack(options);\n};\n\nconst renderLocalVideo = localTracks => {\n  if (roomObj.localParticipant) {\n    if (localTracks && localTracks.length > 0) {\n      const videoTrack = localTracks.find(value => value.kind === 'video');\n\n      if (videoTrack) {\n        // const videoTrack = localVideos[0];\n        const localVideoElem = document.getElementById('localVideo');\n\n        if (localVideoElem) {\n          localVideoElem.innerHTML = '';\n        }\n\n        if (localVideoElem && videoTrack instanceof LocalVideoTrack) {\n          localVideoElem.appendChild(videoTrack.attach());\n        }\n      }\n    }\n  }\n};\n\nconst turnOffAudio = () => {\n  roomObj.localParticipant.audioTracks.forEach(publication => {\n    publication.unpublish();\n    publication.track.stop();\n  });\n};\n\nconst flipCamera = () => {\n  return new Promise((resolve, reject) => {\n    toggleVideo(false).then(() => {\n      var _options$video;\n\n      options.video = {\n        facingMode: typeof options.video !== \"boolean\" && ((_options$video = options.video) === null || _options$video === void 0 ? void 0 : _options$video.facingMode) === 'user' ? 'environment' : 'user'\n      };\n      toggleVideo(true).then(() => {\n        resolve(true);\n      }).catch(reject);\n    }).catch(reject);\n  });\n};\n\nconst turnOffVideo = () => {\n  roomObj.localParticipant.videoTracks.forEach(publication => {\n    publication.track.detach().forEach(element => {\n      element.remove();\n    });\n    publication.unpublish();\n    publication.track.stop();\n  });\n};\n\nconst disconnectFromRoom = () => {\n  return new Promise((resolve, reject) => {\n    if (roomObj) {\n      turnOffAudio();\n      turnOffVideo();\n      roomObj.disconnect();\n    } // roomObj.\n\n\n    resolve(null);\n  });\n};\n\nconst connectToRoom = async (accessToken, options) => {\n  if (!isSupported) {\n    console.error('This browser is not supported by webRTC');\n    return;\n  }\n\n  const connectOptions = { ...options\n  };\n  const tracks = [];\n\n  if (options.audio) {\n    const audioTrack = await createLocalAudio(options.audio).catch(handleMediaError.bind(this, 'audio'));\n\n    if (audioTrack) {\n      tracks.push(audioTrack);\n\n      CommonService._communications.mediaAvailabilitySubject.next({\n        is_available: true,\n        mode: 'audio'\n      });\n    } else {\n      connectOptions.audio = false;\n    }\n  }\n\n  if (options.video) {\n    const videoTrack = await createLocalVideo(options.video).catch(handleMediaError.bind(this, 'video'));\n\n    if (videoTrack) {\n      tracks.push(videoTrack);\n\n      CommonService._communications.mediaAvailabilitySubject.next({\n        is_available: true,\n        mode: 'video'\n      });\n    } else {\n      connectOptions.video = false;\n    }\n  }\n\n  if (tracks && tracks.length > 0) {\n    connectOptions.tracks = tracks;\n  }\n\n  connect(accessToken, connectOptions).then(room => {\n    CommonService._communications.webRtcConnectedSubject.next(true);\n\n    roomObj = room;\n\n    if (connectOptions.tracks && connectOptions.tracks.length > 0) {\n      renderLocalVideo(connectOptions.tracks);\n    } // Set up remote video notifications for the VideoTracks of RemoteParticipants\n    // already in the Room.\n\n\n    roomObj.participants.forEach(participantConnected.bind(this)); // Set up remote video notifications for the VideoTracks of RemoteParticipants\n    // that will join the Room later.\n    // @ts-ignore\n\n    roomObj.on('participantConnected', participantConnected.bind(this)); // @ts-ignore\n\n    roomObj.on('participantDisconnected', participantDisconnected.bind(this)); // @ts-ignore\n\n    roomObj.once('disconnected', (room, error) => {\n      if (error) {\n        CommonService._communications.webRtcConnectedSubject.next(false);\n\n        if (error.code === 53205) {\n          // user logged on from another device\n          CommonService.showToast(error.message, 'error');\n        } else {\n          connectToRoom(accessToken, options);\n        }\n      }\n    });\n  }).catch(error => {\n    CommonService._communications.webRtcConnectedSubject.next(false);\n\n    console.error('Twilio error :', error.message);\n\n    if (mediaErrors.includes(error.name)) {// Handle media error here.\n      // handleMediaError('room', error);\n    }\n\n    if (connectOptions.tracks) {\n      connectOptions.tracks.forEach(track => {\n        if (track.kind === 'video' || track.kind === 'audio') {\n          track.stop();\n        }\n      });\n    }\n\n    CommonService._communications.mediaAvailabilitySubject.next({\n      error: 'Room Connection Failed',\n      is_available: false,\n      mode: 'audio'\n    });\n\n    CommonService._communications.mediaAvailabilitySubject.next({\n      error: 'Room Connection Failed',\n      is_available: false,\n      mode: 'video'\n    });\n  });\n};\n\nconst setupSubscriptionListeners = (participant, publication) => {\n  if (publication.isSubscribed) {// Indicate to the user that the mobile user has added video.\n  } // @ts-ignore\n\n\n  publication.on('subscribed', track => {\n    // console.log('subscribed', track);\n    // Indicate to the user that the mobile user has added video.\n    renderParticipantTrack(participant, track);\n  }); // @ts-ignore\n\n  publication.on('unsubscribed', track => {\n    // console.log('unsubscribed', track);\n    removeParticipantTrack(participant, track); // Indicate to the user that the mobile user has removed video.\n  });\n};\n\nconst participantConnected = participant => {\n  // Set up remote video notifications for the VideoTracks that are\n  // already published.\n  participant.tracks.forEach(setupSubscriptionListeners.bind(this, participant)); // Set up remote video notifications for the VideoTracks that will be\n  // published later.\n  // @ts-ignore\n\n  participant.on('trackPublished', setupSubscriptionListeners.bind(this, participant));\n\n  CommonService._communications.participantDisconnected.next(false);\n};\n\nconst participantDisconnected = participant => {\n  removeParticipantTracks(participant);\n\n  CommonService._communications.participantDisconnected.next(true);\n}; // unsubscribeParticipants(retainer_ids: string[]) {\n//   for (const attendeeId in subscribed_participants_map) {\n//     if(subscribed_participants_map.hasOwnProperty(attendeeId)) {\n//       const participant = subscribed_participants_map[attendeeId];\n//       // console.log('participant ...', retainer_ids, participant.identity, retainer_ids.indexOf(participant.identity) === -1);\n//       if (retainer_ids.indexOf(participant.identity) === -1) {\n//         removeParticipantTracks(participant);\n//         delete subscribed_participants_map[attendeeId];\n//       }\n//     }\n//   }\n//   // subscribed_participants.forEach((participant, i) =>{\n//   //   console.log('participant ...', retainer_ids, participant.identity, retainer_ids.indexOf(participant.identity) === -1);\n//   //   if (retainer_ids.indexOf(participant.identity) === -1) {\n//   //     removeParticipantTracks(participant);\n//   //     subscribed_participants.splice(i, 1);\n//   //   }\n//   // });\n// }\n// connectToUsers(participant_ids: string[]) {\n//   unsubscribeParticipants(participant_ids);\n//   if (roomObj && roomObj.participants) {\n//     roomObj.participants.forEach((participant) => {\n//       if (participant_ids.indexOf(participant.identity) > -1) {\n//         // const found = subscribed_participants.find((p) => p.identity === participant.identity);\n//         if (!subscribed_participants_map.hasOwnProperty(participant.identity)) {\n//           // subscribed_participants.push(participant);\n//           subscribed_participants_map[participant.identity] = participant;\n//           renderParticipantTracks(participant);\n//         } else {\n//           // console.log('already video found');\n//         }\n//       }\n//     });\n//   }\n// }\n\n\nconst renderParticipantTracks = participant => {\n  participant.videoTracks.forEach(publication => {\n    renderParticipantTrack(participant, publication.track);\n  });\n  participant.audioTracks.forEach(publication => {\n    renderParticipantTrack(participant, publication.track);\n  });\n  participant.dataTracks.forEach(publication => {\n    renderParticipantTrack(participant, publication.track);\n  });\n};\n\nconst removeParticipantTracks = participant => {\n  participant.videoTracks.forEach(publication => {\n    removeParticipantTrack(participant, publication.track);\n  });\n  participant.audioTracks.forEach(publication => {\n    removeParticipantTrack(participant, publication.track);\n  });\n  participant.dataTracks.forEach(publication => {\n    removeParticipantTrack(participant, publication.track);\n  });\n};\n\nconst renderParticipantTrack = (participant, track) => {\n  const userId = participant.identity; // console.log('render track', attendee_id, track);\n\n  CommonService._communications.streamSubscribedSubject.next({\n    track,\n    userId\n  }); // if (subscribed_participants.indexOf(attendee_id) > -1) {\n  // }\n\n};\n\nconst removeParticipantTrack = (participant, track) => {\n  const userId = participant.identity;\n\n  CommonService._communications.streamUnsubscribedSubject.next({\n    track,\n    userId\n  }); // console.log('remove track', attendee_id, track);\n  // if (subscribed_participants.indexOf(attendee_id) > -1) {\n  // }\n\n};\n\nconst TwilioService = {\n  connectToRoom,\n  flipCamera,\n  toggleAudio,\n  toggleVideo,\n  disconnectFromRoom,\n  renderParticipantTracks,\n  createLocalTracks,\n  listOfCameras\n};\nexport default TwilioService;","map":{"version":3,"sources":["/Users/divya/Documents/practice/react-alten-app/src/helpers/twilio-service.ts"],"names":["connect","createLocalAudioTrack","createLocalVideoTrack","isSupported","LocalVideoTrack","CommonService","roomObj","options","mediaErrors","toggleAudio","isOn","Promise","resolve","reject","audioTrack","createLocalAudio","audio","catch","handleMediaError","bind","localParticipant","publishTrack","turnOffAudio","listOfCameras","list","navigator","mediaDevices","enumerateDevices","then","devices","device","kind","push","toggleVideo","videoTrack","createLocalVideo","video","renderLocalVideo","turnOffVideo","mode","error","console","name","message","_communications","mediaAvailabilitySubject","next","is_available","createLocalTracks","localTracks","length","find","value","localVideoElem","document","getElementById","innerHTML","appendChild","attach","audioTracks","forEach","publication","unpublish","track","stop","flipCamera","facingMode","videoTracks","detach","element","remove","disconnectFromRoom","disconnect","connectToRoom","accessToken","connectOptions","tracks","room","webRtcConnectedSubject","participants","participantConnected","on","participantDisconnected","once","code","showToast","includes","setupSubscriptionListeners","participant","isSubscribed","renderParticipantTrack","removeParticipantTrack","removeParticipantTracks","renderParticipantTracks","dataTracks","userId","identity","streamSubscribedSubject","streamUnsubscribedSubject","TwilioService"],"mappings":"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","sourcesContent":["import {\r\n    connect,\r\n    ConnectOptions,\r\n    createLocalAudioTrack,\r\n    createLocalVideoTrack,\r\n    isSupported,\r\n    LocalTrack,\r\n    LocalVideoTrack,\r\n    Participant,\r\n    RemoteParticipant,\r\n    RemoteTrack,\r\n    RemoteTrackPublication,\r\n    Room,\r\n} from 'twilio-video';\r\nimport CommonService from './common-service';\r\n\r\nlet roomObj: Room;\r\nlet options: ConnectOptions = {};\r\n// const subscribed_participants_map: { [userId: string]: RemoteParticipant } = {};\r\n\r\nconst mediaErrors = ['NotAllowedError', 'NotFoundError', 'NotReadableError', 'OverconstrainedError', 'TypeError'];\r\n\r\nconst toggleAudio = (isOn = false): Promise<void> => {\r\n    return new Promise(async (resolve, reject) => {\r\n        if (isOn) {\r\n            const audioTrack = await createLocalAudio(options.audio).catch(handleMediaError.bind(this, 'audio'));\r\n            if (audioTrack) {\r\n                await roomObj.localParticipant.publishTrack(audioTrack);\r\n                resolve();\r\n            } else {\r\n                reject();\r\n            }\r\n        } else {\r\n            turnOffAudio();\r\n            resolve();\r\n        }\r\n    });\r\n};\r\n\r\nconst listOfCameras = (): Promise<any[]> => {\r\n    return new Promise((resolve, reject) => {\r\n        const list: any[] = [];\r\n        navigator.mediaDevices.enumerateDevices().then(function (devices) {\r\n            for (let device of devices) {\r\n                if (device.kind === 'videoinput') {\r\n                    list.push(device);\r\n                }\r\n            }\r\n            resolve(list);\r\n        }).catch(reject);\r\n    })\r\n\r\n}\r\n\r\nconst toggleVideo = (isOn = false) => {\r\n    return new Promise(async (resolve, reject) => {\r\n        if (isOn) {\r\n            const videoTrack = await createLocalVideo(options.video).catch(handleMediaError.bind(this, 'video'));\r\n            if (videoTrack) {\r\n                await roomObj.localParticipant.publishTrack(videoTrack);\r\n                renderLocalVideo([videoTrack]);\r\n                resolve(null);\r\n            } else {\r\n                reject();\r\n            }\r\n        } else {\r\n            turnOffVideo();\r\n            resolve(null);\r\n        }\r\n    });\r\n};\r\n\r\nconst handleMediaError = (mode: string, error: any) => {\r\n    console.error('Failed to acquire media:', mode, error.name, error.message);\r\n    CommonService._communications.mediaAvailabilitySubject.next({error: error, is_available: false, mode});\r\n};\r\nconst createLocalTracks = async (options: any): Promise<any> => await createLocalTracks(options);\r\n\r\nconst createLocalVideo = async (options: any) => {\r\n    return await createLocalVideoTrack(options);\r\n};\r\n\r\nconst createLocalAudio = async (options: any) => {\r\n    return await createLocalAudioTrack(options);\r\n};\r\n\r\nconst renderLocalVideo = (localTracks: (LocalTrack | MediaStreamTrack)[]) => {\r\n    if (roomObj.localParticipant) {\r\n        if (localTracks && localTracks.length > 0) {\r\n            const videoTrack = localTracks.find((value) => value.kind === 'video');\r\n            if (videoTrack) {\r\n                // const videoTrack = localVideos[0];\r\n                const localVideoElem = document.getElementById('localVideo');\r\n                if(localVideoElem) {\r\n                    localVideoElem.innerHTML = '';\r\n                }\r\n                if (localVideoElem && videoTrack instanceof LocalVideoTrack) {\r\n                    localVideoElem.appendChild(videoTrack.attach());\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst turnOffAudio = () => {\r\n    roomObj.localParticipant.audioTracks.forEach((publication) => {\r\n        publication.unpublish();\r\n        publication.track.stop();\r\n    });\r\n};\r\nconst flipCamera = () => {\r\n    return new Promise((resolve, reject) => {\r\n        toggleVideo(false).then(() => {\r\n            options.video = {facingMode: typeof options.video !== \"boolean\" && options.video?.facingMode === 'user' ? 'environment' : 'user'}\r\n            toggleVideo(true).then(() => {\r\n                resolve(true);\r\n            }).catch(reject);\r\n        }).catch(reject);\r\n    })\r\n}\r\nconst turnOffVideo = () => {\r\n    roomObj.localParticipant.videoTracks.forEach((publication) => {\r\n        publication.track.detach().forEach((element) => {\r\n            element.remove();\r\n        });\r\n        publication.unpublish();\r\n        publication.track.stop();\r\n    });\r\n};\r\n\r\nconst disconnectFromRoom = () => {\r\n    return new Promise((resolve, reject) => {\r\n        if (roomObj) {\r\n            turnOffAudio();\r\n            turnOffVideo();\r\n            roomObj.disconnect();\r\n        }\r\n\r\n        // roomObj.\r\n        resolve(null);\r\n    });\r\n};\r\n\r\nconst connectToRoom = async (accessToken: string, options: ConnectOptions) => {\r\n    if (!isSupported) {\r\n        console.error('This browser is not supported by webRTC');\r\n        return;\r\n    }\r\n    const connectOptions = {...options};\r\n    const tracks: LocalTrack[] = [];\r\n    if (options.audio) {\r\n        const audioTrack = await createLocalAudio(options.audio).catch(handleMediaError.bind(this, 'audio'));\r\n        if (audioTrack) {\r\n            tracks.push(audioTrack);\r\n            CommonService._communications.mediaAvailabilitySubject.next({is_available: true, mode: 'audio'});\r\n        } else {\r\n            connectOptions.audio = false;\r\n        }\r\n    }\r\n    if (options.video) {\r\n        const videoTrack = await createLocalVideo(options.video).catch(handleMediaError.bind(this, 'video'));\r\n        if (videoTrack) {\r\n            tracks.push(videoTrack);\r\n            CommonService._communications.mediaAvailabilitySubject.next({is_available: true, mode: 'video'});\r\n        } else {\r\n            connectOptions.video = false;\r\n        }\r\n    }\r\n    if (tracks && tracks.length > 0) {\r\n        connectOptions.tracks = tracks;\r\n    }\r\n    connect(accessToken, connectOptions)\r\n        .then((room) => {\r\n            CommonService._communications.webRtcConnectedSubject.next(true);\r\n            roomObj = room;\r\n            if (connectOptions.tracks && connectOptions.tracks.length > 0) {\r\n                renderLocalVideo(connectOptions.tracks);\r\n            }\r\n            // Set up remote video notifications for the VideoTracks of RemoteParticipants\r\n            // already in the Room.\r\n            roomObj.participants.forEach(participantConnected.bind(this));\r\n\r\n            // Set up remote video notifications for the VideoTracks of RemoteParticipants\r\n            // that will join the Room later.\r\n            // @ts-ignore\r\n            roomObj.on('participantConnected', participantConnected.bind(this));\r\n\r\n            // @ts-ignore\r\n            roomObj.on('participantDisconnected', participantDisconnected.bind(this));\r\n\r\n            // @ts-ignore\r\n            roomObj.once('disconnected', (room, error) => {\r\n                if (error) {\r\n                    CommonService._communications.webRtcConnectedSubject.next(false);\r\n                    if (error.code === 53205) {\r\n                        // user logged on from another device\r\n                        CommonService.showToast(error.message, 'error');\r\n                    } else {\r\n                        connectToRoom(accessToken, options);\r\n                    }\r\n                }\r\n            });\r\n        })\r\n        .catch((error) => {\r\n            CommonService._communications.webRtcConnectedSubject.next(false);\r\n            console.error('Twilio error :', error.message);\r\n            if (mediaErrors.includes(error.name)) {\r\n                // Handle media error here.\r\n                // handleMediaError('room', error);\r\n            }\r\n            if (connectOptions.tracks) {\r\n                connectOptions.tracks.forEach((track) => {\r\n                    if (track.kind === 'video' || track.kind === 'audio') {\r\n                        track.stop();\r\n                    }\r\n                });\r\n            }\r\n            CommonService._communications.mediaAvailabilitySubject.next({\r\n                error: 'Room Connection Failed',\r\n                is_available: false,\r\n                mode: 'audio'\r\n            });\r\n            CommonService._communications.mediaAvailabilitySubject.next({\r\n                error: 'Room Connection Failed',\r\n                is_available: false,\r\n                mode: 'video'\r\n            });\r\n        });\r\n};\r\n\r\nconst setupSubscriptionListeners = (participant: RemoteParticipant, publication: RemoteTrackPublication) => {\r\n    if (publication.isSubscribed) {\r\n        // Indicate to the user that the mobile user has added video.\r\n    }\r\n\r\n    // @ts-ignore\r\n    publication.on('subscribed', (track: RemoteTrack) => {\r\n        // console.log('subscribed', track);\r\n        // Indicate to the user that the mobile user has added video.\r\n        renderParticipantTrack(participant, track);\r\n    });\r\n\r\n    // @ts-ignore\r\n    publication.on('unsubscribed', (track: RemoteTrack) => {\r\n        // console.log('unsubscribed', track);\r\n        removeParticipantTrack(participant, track);\r\n        // Indicate to the user that the mobile user has removed video.\r\n    });\r\n};\r\n\r\nconst participantConnected = (participant: RemoteParticipant) => {\r\n    // Set up remote video notifications for the VideoTracks that are\r\n    // already published.\r\n\r\n    participant.tracks.forEach(setupSubscriptionListeners.bind(this, participant));\r\n\r\n    // Set up remote video notifications for the VideoTracks that will be\r\n    // published later.\r\n    // @ts-ignore\r\n    participant.on('trackPublished', setupSubscriptionListeners.bind(this, participant));\r\n    CommonService._communications.participantDisconnected.next(false);\r\n};\r\n\r\nconst participantDisconnected = (participant: RemoteParticipant) => {\r\n    removeParticipantTracks(participant);\r\n    CommonService._communications.participantDisconnected.next(true);\r\n};\r\n\r\n// unsubscribeParticipants(retainer_ids: string[]) {\r\n//   for (const attendeeId in subscribed_participants_map) {\r\n//     if(subscribed_participants_map.hasOwnProperty(attendeeId)) {\r\n//       const participant = subscribed_participants_map[attendeeId];\r\n//       // console.log('participant ...', retainer_ids, participant.identity, retainer_ids.indexOf(participant.identity) === -1);\r\n//       if (retainer_ids.indexOf(participant.identity) === -1) {\r\n//         removeParticipantTracks(participant);\r\n//         delete subscribed_participants_map[attendeeId];\r\n//       }\r\n//     }\r\n//   }\r\n//   // subscribed_participants.forEach((participant, i) =>{\r\n//   //   console.log('participant ...', retainer_ids, participant.identity, retainer_ids.indexOf(participant.identity) === -1);\r\n//   //   if (retainer_ids.indexOf(participant.identity) === -1) {\r\n//   //     removeParticipantTracks(participant);\r\n//   //     subscribed_participants.splice(i, 1);\r\n//   //   }\r\n//   // });\r\n// }\r\n\r\n// connectToUsers(participant_ids: string[]) {\r\n//   unsubscribeParticipants(participant_ids);\r\n//   if (roomObj && roomObj.participants) {\r\n//     roomObj.participants.forEach((participant) => {\r\n//       if (participant_ids.indexOf(participant.identity) > -1) {\r\n//         // const found = subscribed_participants.find((p) => p.identity === participant.identity);\r\n//         if (!subscribed_participants_map.hasOwnProperty(participant.identity)) {\r\n//           // subscribed_participants.push(participant);\r\n//           subscribed_participants_map[participant.identity] = participant;\r\n//           renderParticipantTracks(participant);\r\n//         } else {\r\n//           // console.log('already video found');\r\n//         }\r\n//       }\r\n//     });\r\n//   }\r\n// }\r\n\r\nconst renderParticipantTracks = (participant: RemoteParticipant) => {\r\n    participant.videoTracks.forEach((publication) => {\r\n        renderParticipantTrack(participant, publication.track);\r\n    });\r\n    participant.audioTracks.forEach((publication) => {\r\n        renderParticipantTrack(participant, publication.track);\r\n    });\r\n    participant.dataTracks.forEach((publication) => {\r\n        renderParticipantTrack(participant, publication.track);\r\n    });\r\n};\r\n\r\nconst removeParticipantTracks = (participant: RemoteParticipant) => {\r\n    participant.videoTracks.forEach((publication) => {\r\n        removeParticipantTrack(participant, publication.track);\r\n    });\r\n    participant.audioTracks.forEach((publication) => {\r\n        removeParticipantTrack(participant, publication.track);\r\n    });\r\n    participant.dataTracks.forEach((publication) => {\r\n        removeParticipantTrack(participant, publication.track);\r\n    });\r\n};\r\n\r\nconst renderParticipantTrack = (participant: Participant, track: RemoteTrack | null) => {\r\n    const userId = participant.identity;\r\n    // console.log('render track', attendee_id, track);\r\n    CommonService._communications.streamSubscribedSubject.next({track, userId});\r\n    // if (subscribed_participants.indexOf(attendee_id) > -1) {\r\n    // }\r\n};\r\n\r\nconst removeParticipantTrack = (participant: Participant, track: RemoteTrack | null) => {\r\n    const userId = participant.identity;\r\n    CommonService._communications.streamUnsubscribedSubject.next({track, userId});\r\n    // console.log('remove track', attendee_id, track);\r\n    // if (subscribed_participants.indexOf(attendee_id) > -1) {\r\n    // }\r\n};\r\n\r\nconst TwilioService = {\r\n    connectToRoom,\r\n    flipCamera,\r\n    toggleAudio,\r\n    toggleVideo,\r\n    disconnectFromRoom,\r\n    renderParticipantTracks,\r\n    createLocalTracks,\r\n    listOfCameras,\r\n};\r\n\r\nexport default TwilioService;\r\n"]},"metadata":{},"sourceType":"module"}